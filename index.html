<!DOCTYPE html>
<html>
<head>
  <title>Welcome to My Site</title>
  <style>
  body {
    margin: 0;
    overflow: hidden;
    background-color: #ABD4E6;
  }
  .plane {
    position: absolute;
    left: 0;
    top: -150px;
    background: url('images/planes_spritesheet.gif') no-repeat;
    image-rendering: pixelated;
    animation: flyDown linear infinite;
    /* Rotation will be handled by individual plane styles */
  }
  
  @keyframes flyDown {
    to {
      top: 110%;
    }
  }
  
  .controls {
    position: fixed;
    bottom: 20px;
    left: 20px;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 15px;
    border-radius: 8px;
    font-family: monospace;
    font-size: 14px;
    z-index: 100;
  }
  
  .projectile {
    position: absolute;
    width: 6px;
    height: 18px;
    background: linear-gradient(to bottom, #ff4444, #ff8800, #ffdd00);
    border-radius: 3px;
    box-shadow: 0 0 8px #ff6600, 0 0 16px rgba(255, 68, 68, 0.5);
    z-index: 5;
    transform-origin: center center;
  }
  
  .cloud {
    position: absolute;
    z-index: 15; /* Above jets (z-index: 10) */
    image-rendering: auto; /* Smooth rendering for clouds */
    opacity: 0.95; /* Increased opacity */
  }
  </style>
</head>
<body>
  <style>
    /* Player-controlled SU-33 - 75% smaller */
    .plane:nth-child(2) {
      width: 16px;
      height: 28px;
      background-position: -394px -708px; /* SU-33 sprite */
      background-size: 400%; /* Scale sprite sheet to maintain detail */
      z-index: 10;
      box-shadow: 0 0 3px rgba(255, 255, 255, 0.5);
      display: none; /* Hidden by default */
      transform: translate(-50%, -50%); /* No rotation for player */
      transition: transform 0.1s ease;
      animation: none; /* Override flyDown animation for player */
      position: fixed; /* Use fixed positioning for player control */
    }
    .plane:nth-child(3) {
      width: 17px;
      height: 25px;
      background-position: -392px -316px;
      background-size: 400%;
      transform: rotate(180deg); /* Override base rotation for NPC planes */
    }
    .plane:nth-child(4) {
      width: 23px;
      height: 28px;
      background-position: -380px -456px;
      background-size: 400%;
      transform: rotate(180deg); /* Override base rotation for NPC planes */
    }
    .plane:nth-child(5) {
      width: 21px;
      height: 28px;
      background-position: -384px -604px;
      background-size: 400%;
      transform: rotate(180deg); /* Override base rotation for NPC planes */
    }
    .plane:nth-child(6) {
      width: 15px;
      height: 23px;
      background-position: -512px -188px;
      background-size: 400%;
      transform: rotate(180deg); /* Override base rotation for NPC planes */
    }
  </style>

  <div class="plane"></div>
  <div class="plane" id="playerPlane"></div>
  <div class="plane"></div>
  <div class="plane"></div>
  <div class="plane"></div>

  <!-- Cloud sprites that float above the jets (12 clouds) -->
  <img class="cloud" src="images/clouds/cloud1.png" style="width: 120px; height: 60px; top: 5%;">
  <img class="cloud" src="images/clouds/cloud2.png" style="width: 150px; height: 70px; top: 15%;">
  <img class="cloud" src="images/clouds/cloud3.png" style="width: 100px; height: 50px; top: 25%;">
  <img class="cloud" src="images/clouds/cloud4.png" style="width: 130px; height: 65px; top: 35%;">
  <img class="cloud" src="images/clouds/cloud5.png" style="width: 110px; height: 55px; top: 45%;">
  <img class="cloud" src="images/clouds/cloud1.png" style="width: 140px; height: 70px; top: 55%;">
  <img class="cloud" src="images/clouds/cloud2.png" style="width: 100px; height: 50px; top: 65%;">
  <img class="cloud" src="images/clouds/cloud3.png" style="width: 120px; height: 60px; top: 75%;">
  <img class="cloud" src="images/clouds/cloud4.png" style="width: 110px; height: 55px; top: 85%;">
  <img class="cloud" src="images/clouds/cloud5.png" style="width: 130px; height: 65px; top: 20%;">
  <img class="cloud" src="images/clouds/cloud1.png" style="width: 90px; height: 45px; top: 50%;">
  <img class="cloud" src="images/clouds/cloud3.png" style="width: 160px; height: 80px; top: 70%;">

  <!-- Controls display -->
  <div class="controls">
    <strong>Controls:</strong><br>
    Left Click - Spawn Jet<br>
    W - Move Up<br>
    A - Move Left<br>
    S - Move Down<br>
    D - Move Right<br>
    Space - Fire Projectile
  </div>

  <h1 style="position: relative; z-index: 1;">Hello from GitHub Pages!</h1>
  <p style="position: relative; z-index: 1;">This is my personal website.</p>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // NPC plane data and management
      const npcPlanes = [];
      let npcPlanesStarted = false;
      
      function initializeNPCPlanes() {
        const planes = document.querySelectorAll('.plane');
        console.log('Found planes:', planes.length);
        
        planes.forEach((plane, index) => {
          console.log(`Plane ${index + 1}: id=${plane.id}, element:`, plane);
          
          // Skip plane 2 (index 1) as it's the player plane
          if (plane.id === 'playerPlane') {
            console.log('Skipping player plane');
            return;
          }
          
          // Initially hide all NPC planes
          plane.style.display = 'none';
          console.log(`Hidden NPC plane ${index + 1}`);
          
          // Store plane data for later spawning
          const planeData = {
            element: plane,
            lastFireTime: 0 // Track when this plane last fired
          };
          npcPlanes.push(planeData);
        });
        
        console.log('NPC planes initialized:', npcPlanes.length);
      }
      
      function startNPCPlanes() {
        if (npcPlanesStarted) return;
        npcPlanesStarted = true;
        
        console.log('Starting NPC planes, count:', npcPlanes.length);
        
        npcPlanes.forEach((planeData, index) => {
          const plane = planeData.element;
          
          console.log(`Starting plane ${index + 1}:`, plane);
          
          // Show the plane
          plane.style.display = 'block';
          
          // Random horizontal position (5% to 95%)
          const randomLeft = Math.random() * 90 + 5;
          plane.style.left = randomLeft + '%';
          
          // Random speed (1.33 to 4 seconds) - 50% faster than before
          const randomDuration = (Math.random() * 4 + 2) / 1.5;
          plane.style.animationDuration = randomDuration + 's';
          
          // Random delay (0 to 3 seconds)
          const randomDelay = Math.random() * 3;
          plane.style.animationDelay = randomDelay + 's';
          
          // Random starting position offset (-150 to -300px)
          const randomStart = -(Math.random() * 150 + 150);
          plane.style.top = randomStart + 'px';
          
          // Set initial fire time with random offset
          planeData.lastFireTime = Date.now() + (Math.random() * 5500);
          
          console.log(`Plane ${index + 1} started - left: ${randomLeft}%, duration: ${randomDuration}s, delay: ${randomDelay}s, top: ${randomStart}px`);
        });
        
        console.log('All NPC planes started');
      }
      
      // Initialize NPC planes but don't start them yet
      initializeNPCPlanes();

      // Cloud movement system
      const clouds = document.querySelectorAll('.cloud');
      const cloudData = [];
      
      console.log(`Found ${clouds.length} clouds to animate`);
      
      clouds.forEach((cloud, index) => {
        // Random initial position
        const initialX = Math.random() * 100;
        cloud.style.left = initialX + '%';
        
        // Random speed between 1-7 pixels per second
        const pixelsPerSecond = Math.random() * 6 + 1;
        
        // Random direction (1 or -1)
        const direction = Math.random() > 0.5 ? 1 : -1;
        
        // Higher opacity (0.8 to 1.0)
        const opacity = Math.random() * 0.2 + 0.8;
        cloud.style.opacity = opacity;
        
        // Store cloud data
        cloudData.push({
          element: cloud,
          x: initialX,
          speed: pixelsPerSecond,
          direction: direction
        });
        
        console.log(`Cloud ${index + 1}: speed=${pixelsPerSecond.toFixed(1)}px/s, direction=${direction > 0 ? 'right' : 'left'}, opacity=${opacity.toFixed(2)}`);
      });
      
      // Update clouds position
      let lastTime = Date.now();
      
      function updateClouds() {
        const currentTime = Date.now();
        const deltaTime = (currentTime - lastTime) / 1000; // Convert to seconds
        lastTime = currentTime;
        
        cloudData.forEach(cloud => {
          // Calculate movement in pixels
          const pixelMovement = cloud.speed * deltaTime;
          // Convert to percentage (assuming 1920px width as reference)
          const percentageMovement = (pixelMovement / window.innerWidth) * 100;
          
          // Update position
          cloud.x += percentageMovement * cloud.direction;
          
          // Bounce off edges
          if (cloud.x > 100 && cloud.direction > 0) {
            cloud.direction = -1;
            cloud.x = 100;
          } else if (cloud.x < -15 && cloud.direction < 0) {
            cloud.direction = 1;
            cloud.x = -15;
          }
          
          // Apply position
          cloud.element.style.left = cloud.x + '%';
        });
        
        requestAnimationFrame(updateClouds);
      }
      
      updateClouds();

      // Player-controlled plane system
      const playerPlane = document.getElementById('playerPlane');
      let playerX = 50; // Position percentage
      let playerY = 50; // Position percentage
      const moveSpeed = 1; // Movement speed percentage per keypress (50% slower: 2 * 0.5 = 1)
      let isSpawned = false; // Track if plane is spawned
      let currentRotation = 0; // Track current plane rotation
      
      // Projectile system
      const projectiles = [];
      const npcProjectiles = []; // Track NPC projectiles separately
      const projectileSpeed = 4; // Speed of projectiles
      let lastPlayerFireTime = 0; // Track player firing cooldown
      const playerFireCooldown = 20; // 20ms cooldown between shots
      
      // Track pressed keys for smooth movement
      const keys = {};
      
      // Mouse left click to spawn plane (only once)
      document.addEventListener('mousedown', function(e) {
        // Only respond to left click (button 0)
        if (e.button !== 0) return;
        
        // Don't spawn if already spawned or clicking on controls
        if (isSpawned || e.target.closest('.controls')) return;
        
        // Calculate position as percentage
        playerX = (e.clientX / window.innerWidth) * 100;
        playerY = (e.clientY / window.innerHeight) * 100;
        
        // Disable the flyUp animation for player plane
        playerPlane.style.animation = 'none';
        
        // Show the plane
        playerPlane.style.display = 'block';
        
        // Position the plane
        playerPlane.style.left = playerX + '%';
        playerPlane.style.top = playerY + '%';
        playerPlane.style.bottom = 'auto'; // Override bottom positioning
        
        // Add spawn effect with slight scale animation
        playerPlane.style.transform = 'translate(-50%, -50%) rotate(0deg) scale(0.8)';
        setTimeout(() => {
          playerPlane.style.transform = 'translate(-50%, -50%) rotate(0deg) scale(1)';
        }, 100);
        
        isSpawned = true;
        
        console.log('Player spawned at:', playerX, playerY);
        
        // Start NPC planes when player spawns
        startNPCPlanes();
        
        // Update controls text to show plane is spawned
        const controlsDiv = document.querySelector('.controls');
        controlsDiv.innerHTML = controlsDiv.innerHTML.replace('Left Click - Spawn Jet', 'Jet Spawned! ✓');
        
        // Prevent default behavior
        e.preventDefault();
      });
      
      // Projectile creation function - fires 3 in a straight line
      function createProjectileBurst() {
        if (!isSpawned) return;
        
        // Check cooldown
        const currentTime = Date.now();
        if (currentTime - lastPlayerFireTime < playerFireCooldown) return;
        lastPlayerFireTime = currentTime;
        
        // Calculate direction based on current rotation
        const radians = currentRotation * (Math.PI / 180);
        const directionX = Math.sin(radians);
        const directionY = -Math.cos(radians);
        
        // Create 3 projectiles in a straight line
        for (let i = 0; i < 3; i++) {
          const projectile = document.createElement('div');
          projectile.className = 'projectile';
          
          // Position projectiles in a line along the direction vector
          // Spread them 1.5% apart in the direction they're traveling
          const lineOffset = (i - 1) * 1.5; // -1.5%, 0%, +1.5% spacing
          const offsetX = playerX + (directionX * lineOffset);
          const offsetY = playerY + (directionY * lineOffset);
          
          projectile.style.left = offsetX + '%';
          projectile.style.top = offsetY + '%';
          
          // Rotate projectile to face the direction it's traveling with proper centering
          projectile.style.transform = `translate(-50%, -50%) rotate(${currentRotation}deg)`;
          
          // Store projectile data
          const projectileData = {
            element: projectile,
            x: offsetX,
            y: offsetY,
            directionX: directionX,
            directionY: directionY,
            rotation: currentRotation
          };
          
          projectiles.push(projectileData);
          document.body.appendChild(projectile);
        }
      }
      
      // NPC projectile creation function
      function createNPCProjectile(npcPlane) {
        const rect = npcPlane.getBoundingClientRect();
        const x = (rect.left + rect.width / 2) / window.innerWidth * 100;
        const y = (rect.top + rect.height / 2) / window.innerHeight * 100;
        
        const projectile = document.createElement('div');
        projectile.className = 'projectile';
        projectile.style.left = x + '%';
        projectile.style.top = y + '%';
        projectile.style.background = 'linear-gradient(to bottom, #ff6666, #ff3333, #cc0000)'; // Red gradient for NPC
        projectile.style.transform = 'translate(-50%, -50%) rotate(180deg)'; // Point downward
        
        const projectileData = {
          element: projectile,
          x: x,
          y: y,
          directionX: 0,
          directionY: 1, // Move downward
          rotation: 180,
          isNPC: true
        };
        
        npcProjectiles.push(projectileData);
        document.body.appendChild(projectile);
      }
      
      // Update projectiles
      function updateProjectiles() {
        // Update player projectiles
        for (let i = projectiles.length - 1; i >= 0; i--) {
          const proj = projectiles[i];
          
          // Move projectile
          proj.x += proj.directionX * projectileSpeed;
          proj.y += proj.directionY * projectileSpeed;
          
          // Update position and maintain rotation
          proj.element.style.left = proj.x + '%';
          proj.element.style.top = proj.y + '%';
          proj.element.style.transform = `translate(-50%, -50%) rotate(${proj.rotation}deg)`;
          
          // Remove if off screen
          if (proj.x < -5 || proj.x > 105 || proj.y < -5 || proj.y > 105) {
            proj.element.remove();
            projectiles.splice(i, 1);
          }
        }
        
        // Update NPC projectiles
        for (let i = npcProjectiles.length - 1; i >= 0; i--) {
          const proj = npcProjectiles[i];
          
          // Move projectile downward
          proj.y += projectileSpeed;
          
          // Update position
          proj.element.style.top = proj.y + '%';
          
          // Remove if off screen
          if (proj.y > 105) {
            proj.element.remove();
            npcProjectiles.splice(i, 1);
          }
        }
      }
      
      // NPC firing system
      function updateNPCFiring() {
        if (!npcPlanesStarted) return;
        
        const currentTime = Date.now();
        
        npcPlanes.forEach(planeData => {
          // Check if 5.5 seconds have passed since last fire
          if (currentTime - planeData.lastFireTime >= 5500) {
            // Check if plane is visible on screen
            const rect = planeData.element.getBoundingClientRect();
            if (rect.top > -50 && rect.top < window.innerHeight + 50) {
              createNPCProjectile(planeData.element);
              planeData.lastFireTime = currentTime;
            }
          }
        });
      }
      
      // Keyboard event listeners
      document.addEventListener('keydown', function(e) {
        if (!isSpawned) return; // Don't do anything if not spawned
        
        const key = e.key.toLowerCase();
        
        // Handle spacebar for firing burst
        if (key === ' ' || key === 'space') {
          createProjectileBurst();
          e.preventDefault();
          return;
        }
        
        keys[key] = true;
        
        // Only prevent default for movement keys
        if (['w', 'a', 's', 'd', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(key)) {
          e.preventDefault();
        }
      });
      
      document.addEventListener('keyup', function(e) {
        keys[e.key.toLowerCase()] = false;
      });
      
      // Game loop for smooth movement
      function updatePlayerPosition() {
        if (isSpawned) {
          let moved = false;
          let dx = 0, dy = 0; // Direction vectors (can be fractional for smooth movement)
          
          // Calculate movement vectors with precise directional control
          if (keys['w'] || keys['arrowup']) {
            dy -= 1;
          }
          if (keys['s'] || keys['arrowdown']) {
            dy += 1;
          }
          if (keys['a'] || keys['arrowleft']) {
            dx -= 1;
          }
          if (keys['d'] || keys['arrowright']) {
            dx += 1;
          }
          
          // If moving, calculate precise movement and rotation
          if (dx !== 0 || dy !== 0) {
            // Normalize diagonal movement to prevent faster diagonal speed
            const magnitude = Math.sqrt(dx * dx + dy * dy);
            const normalizedDx = dx / magnitude;
            const normalizedDy = dy / magnitude;
            
            // Apply normalized movement
            const newX = playerX + (normalizedDx * moveSpeed);
            const newY = playerY + (normalizedDy * moveSpeed);
            
            // Boundary checking
            playerX = Math.max(5, Math.min(95, newX));
            playerY = Math.max(5, Math.min(95, newY));
            
            // Calculate precise rotation angle
            // Math.atan2 gives us angles from -180° to 180°
            // We convert so that "up" (negative Y) is 0°
            currentRotation = Math.atan2(normalizedDx, -normalizedDy) * (180 / Math.PI);
            
            // Update plane position and rotation with precise angle
            playerPlane.style.left = playerX + '%';
            playerPlane.style.top = playerY + '%';
            playerPlane.style.transform = `translate(-50%, -50%) rotate(${currentRotation.toFixed(1)}deg)`;
            
            moved = true;
          }
          
          // Example angles that are now possible:
          // W only: 0°
          // W+D: 45°
          // D only: 90°
          // S+D: 135°
          // S only: 180°
          // S+A: -135° (or 225°)
          // A only: -90° (or 270°)
          // W+A: -45° (or 315°)
          // And any combination creates precise intermediate angles
        }
        
        // Update projectiles
        updateProjectiles();
        
        // Update NPC firing
        updateNPCFiring();
        
        // Continue the game loop
        requestAnimationFrame(updatePlayerPosition);
      }
      
      // Start the game loop
      updatePlayerPosition();
    });
  </script>
</body>
</html>

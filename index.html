<!DOCTYPE html>
<html>
<head>
  <title>Welcome to My Site</title>
  <style>
  body {
    margin: 0;
    overflow: hidden;
    background-color: #ABD4E6;
  }
  .plane {
    position: absolute;
    left: 0;
    bottom: -150px;
    background: url('images/planes_spritesheet.gif') no-repeat;
    image-rendering: pixelated;
    animation: flyUp linear infinite;
  }
  
  @keyframes flyUp {
    to {
      bottom: 110%;
    }
  }
  
  .controls {
    position: fixed;
    bottom: 20px;
    left: 20px;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 15px;
    border-radius: 8px;
    font-family: monospace;
    font-size: 14px;
    z-index: 100;
  }
  
  .projectile {
    position: absolute;
    width: 6px;
    height: 18px;
    background: linear-gradient(to bottom, #ff4444, #ff8800, #ffdd00);
    border-radius: 3px;
    box-shadow: 0 0 8px #ff6600, 0 0 16px rgba(255, 68, 68, 0.5);
    z-index: 5;
    transform-origin: center center;
  }
  
  .cloud {
    position: absolute;
    background: radial-gradient(ellipse at center, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.4));
    border-radius: 50%;
    opacity: 0.7;
    z-index: 15; /* Above jets (z-index: 10) */
    animation: floatCloud linear infinite;
  }
  
  .cloud::before {
    content: '';
    position: absolute;
    width: 80%;
    height: 80%;
    background: radial-gradient(ellipse at center, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.4));
    border-radius: 50%;
    top: -30%;
    left: -20%;
  }
  
  .cloud::after {
    content: '';
    position: absolute;
    width: 70%;
    height: 70%;
    background: radial-gradient(ellipse at center, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.4));
    border-radius: 50%;
    bottom: -20%;
    right: -15%;
  }
  
  @keyframes floatCloud {
    from {
      left: -30%;
    }
    to {
      left: 130%;
    }
  }
  </style>
</head>
<body>
  <style>
    /* Player-controlled SU-33 */
    .plane:nth-child(2) {
      width: 64px;
      height: 111px;
      background-position: -394px -708px; /* SU-33 sprite */
      z-index: 10;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
      display: none; /* Hidden by default */
      transform: translate(-50%, -50%);
      transition: transform 0.1s ease;
    }
    .plane:nth-child(3) {
      width: 68px;
      height: 100px;
      background-position: -392px -316px;
    }
    .plane:nth-child(4) {
      width: 92px;
      height: 112px;
      background-position: -380px -456px;
    }
    .plane:nth-child(5) {
      width: 84px;
      height: 112px;
      background-position: -384px -604px;
    }
    .plane:nth-child(6) {
      width: 60px;
      height: 92px;
      background-position: -512px -188px;
    }
  </style>

  <div class="plane"></div>
  <div class="plane" id="playerPlane"></div>
  <div class="plane"></div>
  <div class="plane"></div>
  <div class="plane"></div>

  <!-- Clouds that float above the jets -->
  <div class="cloud" style="width: 120px; height: 60px; top: 10%;"></div>
  <div class="cloud" style="width: 150px; height: 70px; top: 25%;"></div>
  <div class="cloud" style="width: 100px; height: 50px; top: 40%;"></div>
  <div class="cloud" style="width: 130px; height: 65px; top: 60%;"></div>
  <div class="cloud" style="width: 110px; height: 55px; top: 75%;"></div>

  <!-- Controls display -->
  <div class="controls">
    <strong>Controls:</strong><br>
    Left Click - Spawn Jet<br>
    W - Move Up<br>
    A - Move Left<br>
    S - Move Down<br>
    D - Move Right<br>
    Space - Fire Projectile
  </div>

  <h1 style="position: relative; z-index: 1;">Hello from GitHub Pages!</h1>
  <p style="position: relative; z-index: 1;">This is my personal website.</p>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Randomize NPC plane speeds and positions (excluding player plane)
      const planes = document.querySelectorAll('.plane');
      
      planes.forEach((plane, index) => {
        // Skip plane 2 (index 1) as it's the player plane
        if (plane.id === 'playerPlane') return;
        
        // Random horizontal position (5% to 95%)
        const randomLeft = Math.random() * 90 + 5;
        plane.style.left = randomLeft + '%';
        
        // Random speed (1.33 to 4 seconds) - 50% faster than before
        const randomDuration = (Math.random() * 4 + 2) / 1.5;
        plane.style.animationDuration = randomDuration + 's';
        
        // Random delay (0 to 3 seconds)
        const randomDelay = Math.random() * 3;
        plane.style.animationDelay = randomDelay + 's';
        
        // Random starting position offset (-150 to -300px)
        const randomStart = -(Math.random() * 150 + 150);
        plane.style.bottom = randomStart + 'px';
      });

      // Randomize cloud speeds and delays
      const clouds = document.querySelectorAll('.cloud');
      clouds.forEach((cloud, index) => {
        // Random speed (15 to 30 seconds)
        const cloudDuration = Math.random() * 15 + 15;
        cloud.style.animationDuration = cloudDuration + 's';
        
        // Random delay to stagger cloud positions
        const cloudDelay = Math.random() * cloudDuration;
        cloud.style.animationDelay = cloudDelay + 's';
        
        // Random opacity (0.5 to 0.8)
        cloud.style.opacity = Math.random() * 0.3 + 0.5;
      });

      // Player-controlled plane system
      const playerPlane = document.getElementById('playerPlane');
      let playerX = 50; // Position percentage
      let playerY = 50; // Position percentage
      const moveSpeed = 1; // Movement speed percentage per keypress (50% slower: 2 * 0.5 = 1)
      let isSpawned = false; // Track if plane is spawned
      let currentRotation = 0; // Track current plane rotation
      
      // Projectile system
      const projectiles = [];
      const projectileSpeed = 4; // Speed of projectiles
      
      // Track pressed keys for smooth movement
      const keys = {};
      
      // Mouse left click to spawn plane (only once)
      document.addEventListener('mousedown', function(e) {
        // Only respond to left click (button 0)
        if (e.button !== 0) return;
        
        // Don't spawn if already spawned or clicking on controls
        if (isSpawned || e.target.closest('.controls')) return;
        
        // Calculate position as percentage
        playerX = (e.clientX / window.innerWidth) * 100;
        playerY = (e.clientY / window.innerHeight) * 100;
        
        // Disable the flyUp animation for player plane
        playerPlane.style.animation = 'none';
        
        // Show the plane
        playerPlane.style.display = 'block';
        
        // Position the plane
        playerPlane.style.left = playerX + '%';
        playerPlane.style.top = playerY + '%';
        playerPlane.style.bottom = 'auto'; // Override bottom positioning
        
        // Add spawn effect with slight scale animation
        playerPlane.style.transform = 'translate(-50%, -50%) rotate(0deg) scale(0.8)';
        setTimeout(() => {
          playerPlane.style.transform = 'translate(-50%, -50%) rotate(0deg) scale(1)';
        }, 100);
        
        isSpawned = true;
        
        // Update controls text to show plane is spawned
        const controlsDiv = document.querySelector('.controls');
        controlsDiv.innerHTML = controlsDiv.innerHTML.replace('Left Click - Spawn Jet', 'Jet Spawned! ✓');
        
        // Prevent default behavior
        e.preventDefault();
      });
      
      // Projectile creation function - fires 3 in a straight line
      function createProjectileBurst() {
        if (!isSpawned) return;
        
        // Calculate direction based on current rotation
        const radians = currentRotation * (Math.PI / 180);
        const directionX = Math.sin(radians);
        const directionY = -Math.cos(radians);
        
        // Create 3 projectiles in a straight line
        for (let i = 0; i < 3; i++) {
          const projectile = document.createElement('div');
          projectile.className = 'projectile';
          
          // Position projectiles in a line along the direction vector
          // Spread them 1.5% apart in the direction they're traveling
          const lineOffset = (i - 1) * 1.5; // -1.5%, 0%, +1.5% spacing
          const offsetX = playerX + (directionX * lineOffset);
          const offsetY = playerY + (directionY * lineOffset);
          
          projectile.style.left = offsetX + '%';
          projectile.style.top = offsetY + '%';
          
          // Rotate projectile to face the direction it's traveling with proper centering
          projectile.style.transform = `translate(-50%, -50%) rotate(${currentRotation}deg)`;
          
          // Store projectile data
          const projectileData = {
            element: projectile,
            x: offsetX,
            y: offsetY,
            directionX: directionX,
            directionY: directionY,
            rotation: currentRotation
          };
          
          projectiles.push(projectileData);
          document.body.appendChild(projectile);
        }
      }
      
      // Update projectiles
      function updateProjectiles() {
        for (let i = projectiles.length - 1; i >= 0; i--) {
          const proj = projectiles[i];
          
          // Move projectile
          proj.x += proj.directionX * projectileSpeed;
          proj.y += proj.directionY * projectileSpeed;
          
          // Update position and maintain rotation
          proj.element.style.left = proj.x + '%';
          proj.element.style.top = proj.y + '%';
          proj.element.style.transform = `translate(-50%, -50%) rotate(${proj.rotation}deg)`;
          
          // Remove if off screen
          if (proj.x < -5 || proj.x > 105 || proj.y < -5 || proj.y > 105) {
            proj.element.remove();
            projectiles.splice(i, 1);
          }
        }
      }
      
      // Keyboard event listeners
      document.addEventListener('keydown', function(e) {
        if (!isSpawned) return; // Don't do anything if not spawned
        
        const key = e.key.toLowerCase();
        
        // Handle spacebar for firing burst
        if (key === ' ' || key === 'space') {
          createProjectileBurst();
          e.preventDefault();
          return;
        }
        
        keys[key] = true;
        
        // Only prevent default for movement keys
        if (['w', 'a', 's', 'd', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(key)) {
          e.preventDefault();
        }
      });
      
      document.addEventListener('keyup', function(e) {
        keys[e.key.toLowerCase()] = false;
      });
      
      // Game loop for smooth movement
      function updatePlayerPosition() {
        if (isSpawned) {
          let moved = false;
          let dx = 0, dy = 0; // Direction vectors (can be fractional for smooth movement)
          
          // Calculate movement vectors with precise directional control
          if (keys['w'] || keys['arrowup']) {
            dy -= 1;
          }
          if (keys['s'] || keys['arrowdown']) {
            dy += 1;
          }
          if (keys['a'] || keys['arrowleft']) {
            dx -= 1;
          }
          if (keys['d'] || keys['arrowright']) {
            dx += 1;
          }
          
          // If moving, calculate precise movement and rotation
          if (dx !== 0 || dy !== 0) {
            // Normalize diagonal movement to prevent faster diagonal speed
            const magnitude = Math.sqrt(dx * dx + dy * dy);
            const normalizedDx = dx / magnitude;
            const normalizedDy = dy / magnitude;
            
            // Apply normalized movement
            const newX = playerX + (normalizedDx * moveSpeed);
            const newY = playerY + (normalizedDy * moveSpeed);
            
            // Boundary checking
            playerX = Math.max(5, Math.min(95, newX));
            playerY = Math.max(5, Math.min(95, newY));
            
            // Calculate precise rotation angle
            // Math.atan2 gives us angles from -180° to 180°
            // We convert so that "up" (negative Y) is 0°
            currentRotation = Math.atan2(normalizedDx, -normalizedDy) * (180 / Math.PI);
            
            // Update plane position and rotation with precise angle
            playerPlane.style.left = playerX + '%';
            playerPlane.style.top = playerY + '%';
            playerPlane.style.transform = `translate(-50%, -50%) rotate(${currentRotation.toFixed(1)}deg)`;
            
            moved = true;
          }
          
          // Example angles that are now possible:
          // W only: 0°
          // W+D: 45°
          // D only: 90°
          // S+D: 135°
          // S only: 180°
          // S+A: -135° (or 225°)
          // A only: -90° (or 270°)
          // W+A: -45° (or 315°)
          // And any combination creates precise intermediate angles
        }
        
        // Update projectiles
        updateProjectiles();
        
        // Continue the game loop
        requestAnimationFrame(updatePlayerPosition);
      }
      
      // Start the game loop
      updatePlayerPosition();
    });
  </script>
</body>
</html>
